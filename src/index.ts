import { readFile } from 'node:fs/promises';
import { type Config, loadConfig } from './config.js';
import {
  buildGlobalDiff,
  buildNumberedPatch,
  filterDiffFiles,
  parseUnifiedDiff,
  resolveCommentPosition,
  resolveEndPosition,
} from './diff.js';
import { type AIGlobalReview, type AIReview, GeminiClient, type PRGoal } from './gemini.js';
import {
  addCommentReaction,
  createReview,
  extractLinkedIssueRefs,
  fetchFileContent,
  fetchIssue,
  fetchPullRequest,
  fetchPullRequestCommits,
  fetchPullRequestDiff,
  fetchRepoFileStructure,
  postIssueComment,
  type ReviewComment,
} from './github.js';
import { buildGlobalPrompt, buildGoalPrompt, buildPrompt } from './prompt.js';
import type { RetryOptions } from './retry.js';
import { pLimit } from './util.js';

const MAX_COMMENTS = 100;

const SEVERITY_BADGES = {
  high: { emoji: 'ðŸ”´', label: 'High' },
  medium: { emoji: 'ðŸ”¶', label: 'Medium' },
  low: { emoji: 'ðŸ”·', label: 'Low' },
} as const;

const DEFAULT_BADGE = SEVERITY_BADGES.medium;

export function severityBadge(priority: string): string {
  const badge = SEVERITY_BADGES[priority as keyof typeof SEVERITY_BADGES] ?? DEFAULT_BADGE;
  return `**${badge.emoji} ${badge.label}**`;
}

export type EventPayload = {
  issue?: {
    number?: number;
    pull_request?: unknown;
  };
  comment?: {
    id?: number;
    body?: string;
  };
  repository?: {
    full_name?: string;
  };
};

export type Dependencies = {
  loadEventPayload: (path: string) => Promise<EventPayload>;
  fetchPullRequest: typeof fetchPullRequest;
  fetchPullRequestDiff: typeof fetchPullRequestDiff;
  createReview: typeof createReview;
  postIssueComment: typeof postIssueComment;
  addCommentReaction: typeof addCommentReaction;
  createGeminiClient: (
    apiKey: string,
    modelName: string,
    retryOptions?: RetryOptions,
  ) => {
    review: (prompt: string) => Promise<AIReview[]>;
    reviewGlobal: (prompt: string) => Promise<AIGlobalReview>;
    generatePRGoal: (prompt: string) => Promise<PRGoal>;
  };
  fetchPullRequestCommits: typeof fetchPullRequestCommits;
  fetchIssue: typeof fetchIssue;
  extractLinkedIssueRefs: typeof extractLinkedIssueRefs;
  fetchFileContent: (
    owner: string,
    repo: string,
    path: string,
    token: string,
    ref?: string,
  ) => Promise<string>;
  fetchRepoFileStructure: typeof fetchRepoFileStructure;
};

export type RunResult = {
  skipped: boolean;
  skippedReason?: string;
  summary?: string;
  comments: ReviewComment[];
  reviews: AIReview[];
  globalReview?: AIGlobalReview;
};

export function summarizeComments(
  comments: ReviewComment[],
  reviews: AIReview[],
  fileCount: number,
  globalReview?: AIGlobalReview,
): string {
  const counts: Record<string, number> = {
    high: 0,
    medium: 0,
    low: 0,
  };

  for (const review of reviews) {
    const key = review.priority || 'medium';
    if (counts[key] !== undefined) counts[key] += 1;
  }

  const lines: string[] = [];
  lines.push('ðŸ¤– **Gemini PR Review**');
  lines.push('');
  lines.push(`Reviewed **${fileCount}** file(s).`);
  lines.push(`Generated **${comments.length}** inline comment(s).`);
  lines.push('');

  for (const [key, { emoji }] of Object.entries(SEVERITY_BADGES)) {
    lines.push(`- ${emoji} ${key}: ${counts[key]}`);
  }

  lines.push('');
  lines.push(
    '> This review was automatically generated by Gemini. Please verify before applying changes.',
  );

  if (globalReview && (globalReview.summary || globalReview.findings.length > 0)) {
    lines.push('');
    lines.push('## PR-level summary');
    if (globalReview.summary) {
      lines.push(globalReview.summary);
    }
    if (globalReview.findings.length > 0) {
      lines.push('');
      lines.push('Cross-file findings:');
      for (const finding of globalReview.findings) {
        lines.push(`- ${finding}`);
      }
    }
  }

  if (comments.length === 0) {
    lines.push('');
    lines.push('No issues detected in the reviewed changes.');
  }

  return lines.join('\n');
}

export async function loadEventPayload(path: string): Promise<EventPayload> {
  const raw = await readFile(path, 'utf-8');
  return JSON.parse(raw) as EventPayload;
}

export function hasCommandTrigger(body: string, trigger: string): boolean {
  return body.toLowerCase().includes(trigger.toLowerCase());
}

export async function run(params: {
  config: Config;
  env: NodeJS.ProcessEnv;
  deps: Dependencies;
}): Promise<RunResult> {
  const { config, env, deps } = params;

  const eventPath = env.GITHUB_EVENT_PATH;
  const eventName = env.GITHUB_EVENT_NAME;

  if (!eventPath || !eventName) {
    throw new Error('Missing GITHUB_EVENT_PATH or GITHUB_EVENT_NAME');
  }

  if (eventName !== 'issue_comment') {
    console.log(`Skipping: unsupported event ${eventName}`);
    return {
      skipped: true,
      skippedReason: `unsupported event ${eventName}`,
      comments: [],
      reviews: [],
    };
  }

  const event = await deps.loadEventPayload(eventPath);
  const isPullRequest = Boolean(event.issue?.pull_request);
  if (!isPullRequest) {
    console.log('Skipping: comment is not on a pull request');
    return {
      skipped: true,
      skippedReason: 'not a pull request comment',
      comments: [],
      reviews: [],
    };
  }

  const commentBody = event.comment?.body || '';
  if (!hasCommandTrigger(commentBody, config.commandTrigger)) {
    console.log('Skipping: trigger not found in comment');
    return { skipped: true, skippedReason: 'trigger not found', comments: [], reviews: [] };
  }

  const repoFullName = event.repository?.full_name || '';
  const [owner, repo] = repoFullName.split('/');
  const pullNumber = event.issue?.number || 0;

  if (!owner || !repo || !pullNumber) {
    throw new Error('Invalid repository or pull request details in event payload');
  }

  console.log(`Reviewing ${owner}/${repo}#${pullNumber}`);

  const commentId = event.comment?.id;
  if (commentId) {
    deps
      .addCommentReaction(owner, repo, commentId, 'eyes', config.githubToken)
      .catch((err) => console.error(`Failed to add reaction: ${err.message}`));
  }

  const pr = await deps.fetchPullRequest(owner, repo, pullNumber, config.githubToken);
  const diffText = await deps.fetchPullRequestDiff(owner, repo, pullNumber, config.githubToken);

  const parsedFiles = parseUnifiedDiff(diffText);
  const diffOptions = {
    includePatterns: config.includePatterns,
    excludePatterns: config.excludePatterns,
    maxFiles: config.maxFiles,
    maxHunksPerFile: config.maxHunksPerFile,
    maxLinesPerHunk: config.maxLinesPerHunk,
  };
  const filteredFiles = filterDiffFiles(parsedFiles, diffOptions);

  const gemini = deps.createGeminiClient(config.geminiApiKey, config.geminiModel, {
    maxAttempts: config.retryMaxAttempts,
    initialDelayMs: config.retryInitialDelayMs,
  });

  console.log('Fetching PR context...');
  const [commits, repoStructure, readme] = await Promise.all([
    deps.fetchPullRequestCommits(owner, repo, pullNumber, config.githubToken),
    deps.fetchRepoFileStructure(owner, repo, config.githubToken, pr.baseBranch),
    deps.fetchFileContent(owner, repo, 'README.md', config.githubToken, pr.baseBranch),
  ]);

  const issueRefs = deps.extractLinkedIssueRefs(pr.body, owner, repo);
  const linkedIssues = (
    await Promise.all(
      issueRefs.map((ref) =>
        deps.fetchIssue(ref.owner, ref.repo, ref.issueNumber, config.githubToken),
      ),
    )
  ).filter((issue) => issue.title);

  let prGoal: PRGoal | undefined;
  try {
    const goalPrompt = buildGoalPrompt({
      prTitle: pr.title,
      prDescription: pr.body,
      commits,
      linkedIssues,
    });
    console.log('Generating PR goal...');
    prGoal = await gemini.generatePRGoal(goalPrompt);
    console.log(`PR Goal: ${prGoal.goal}`);
  } catch (error) {
    console.warn(`Failed to generate PR goal: ${(error as Error).message}`);
  }

  const allReviews: AIReview[] = [];
  const comments: ReviewComment[] = [];
  const commentKeys = new Set<string>();
  let globalReview: AIGlobalReview | undefined;

  if (config.globalReview) {
    const globalDiff = buildGlobalDiff(filteredFiles, diffOptions, config.globalMaxLines);
    let finalGlobalDiff = globalDiff || '';

    // Smart Context Logic: If global diff is too big, fallback to file list + critical files
    if (globalDiff && globalDiff.length > 50000) {
      // ~12k tokens, safe buffer for typical models
      console.log('Global diff is too large, using smart context strategy...');
      const fileList = filteredFiles.map((f) => f.path).join('\n');

      // Heuristic: Critical files (configs, types, core logic)
      const criticalFiles = filteredFiles.filter(
        (f) =>
          f.path.includes('package.json') ||
          f.path.includes('tsconfig.json') ||
          f.path.endsWith('.d.ts') ||
          f.path.includes('src/index') ||
          f.path.includes('src/config'),
      );

      const criticalDiffs = criticalFiles
        .map((f) =>
          buildNumberedPatch(f, {
            includePatterns: [],
            excludePatterns: [],
            maxFiles: 1,
            maxHunksPerFile: 5,
            maxLinesPerHunk: 50,
          }).lines.join('\n'),
        )
        .join('\n\n');

      finalGlobalDiff = `Files changed:\n${fileList}\n\nCritical file diffs:\n${criticalDiffs}`;
    }

    if (finalGlobalDiff) {
      const globalPrompt = buildGlobalPrompt({
        prTitle: pr.title,
        prDescription: pr.body,
        reviewMode: config.reviewMode,
        reviewInstructions: config.reviewInstructions,
        globalDiff: finalGlobalDiff,
        prGoal,
        repoContext: {
          readme: readme || '',
          fileStructure: repoStructure || '',
        },
      });

      console.log(`Analyzing global PR context...`);
      globalReview = await gemini.reviewGlobal(globalPrompt);
    }
  }

  const MAX_CONCURRENT_REVIEWS = 5;

  const fileReviews = await pLimit(
    filteredFiles.map((file) => async () => {
      // Strict early exit check to avoid expensive LLM calls
      if (comments.length >= MAX_COMMENTS) {
        return [];
      }

      const numbered = buildNumberedPatch(file, {
        includePatterns: [],
        excludePatterns: [],
        maxFiles: config.maxFiles,
        maxHunksPerFile: config.maxHunksPerFile,
        maxLinesPerHunk: config.maxLinesPerHunk,
      });

      if (numbered.lines.length === 0) return [];

      const prompt = buildPrompt({
        prTitle: pr.title,
        prDescription: pr.body,
        filePath: file.path,
        reviewMode: config.reviewMode,
        reviewInstructions: config.reviewInstructions,
        numberedDiff: numbered.lines.join('\n'),
        globalSummary: globalReview?.summary,
        globalFindings: globalReview?.findings,
        prGoal,
        repoContext: {
          readme: readme || '',
          fileStructure: repoStructure || '',
        },
      });

      console.log(`Analyzing ${file.path} (${numbered.lines.length} diff lines)`);

      const reviews = await gemini.review(prompt);
      const fileComments: ReviewComment[] = [];

      for (const review of reviews) {
        // Re-check limit within the loop to handle multiple reviews per file
        if (comments.length + fileComments.length >= MAX_COMMENTS) break;

        const startResolved = resolveCommentPosition(
          review.lineNumber,
          numbered.lineMeta,
          numbered.hunkPositions,
        );

        if (!startResolved) continue;

        const key = `${file.path}:${startResolved.fileLineNumber}:${review.reviewComment}`;
        if (commentKeys.has(key)) continue;
        commentKeys.add(key);

        const badge = severityBadge(review.priority || 'medium');

        const comment: ReviewComment = {
          path: file.path,
          body: `${badge} â€” ${review.reviewComment}`,
          line: startResolved.fileLineNumber,
          side: 'RIGHT',
        };

        // Multi-line range: resolve end position if endLineNumber > lineNumber
        if (review.endLineNumber != null && review.endLineNumber > review.lineNumber) {
          const endResolved = resolveEndPosition(
            review.endLineNumber,
            numbered.lineMeta,
            numbered.hunkPositions,
          );

          if (endResolved) {
            const startMeta = numbered.lineMeta.get(review.lineNumber);
            const endMeta = numbered.lineMeta.get(review.endLineNumber);

            // Guard: both must be in the same hunk, and end must be after start
            if (
              startMeta &&
              endMeta &&
              startMeta.hunkIndex === endMeta.hunkIndex &&
              endResolved.fileLineNumber > startResolved.fileLineNumber
            ) {
              comment.start_line = startResolved.fileLineNumber;
              comment.start_side = 'RIGHT';
              comment.line = endResolved.fileLineNumber;
            }
          }
        }

        fileComments.push(comment);
      }

      // Add to shared array safely (JS is single threaded, so this is safe between awaits)
      comments.push(...fileComments);
      return reviews;
    }),
    MAX_CONCURRENT_REVIEWS,
  );

  allReviews.push(...fileReviews.flat());

  const summary = summarizeComments(comments, allReviews, filteredFiles.length, globalReview);

  try {
    await deps.createReview(pr, config.githubToken, summary, comments);
    console.log('Review created successfully');
  } catch (error) {
    console.error(`Failed to create review: ${(error as Error).message}`);
    console.log('Posting summary as issue comment instead...');
    await deps.postIssueComment(pr, config.githubToken, summary);
  }

  return { skipped: false, summary, comments, reviews: allReviews, globalReview };
}

async function main(): Promise<void> {
  const config = loadConfig();

  const deps: Dependencies = {
    loadEventPayload,
    fetchPullRequest,
    fetchPullRequestDiff,
    fetchPullRequestCommits,
    fetchIssue,
    extractLinkedIssueRefs,
    createReview,
    postIssueComment,
    addCommentReaction,
    createGeminiClient: (apiKey, modelName, retryOptions) =>
      new GeminiClient(apiKey, modelName, retryOptions),
    fetchFileContent,
    fetchRepoFileStructure,
  };

  await run({ config, env: process.env, deps });
}

if (import.meta.main) {
  main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
  });
}
