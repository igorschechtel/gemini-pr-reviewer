import { readFile } from "node:fs/promises";
import { loadConfig, type Config } from "./config";
import {
  parseUnifiedDiff,
  filterDiffFiles,
  buildNumberedPatch,
  adjustToReviewablePosition,
  buildGlobalDiff
} from "./diff";
import { GeminiClient, type AIReview, type AIGlobalReview } from "./gemini";
import { buildPrompt, buildGlobalPrompt } from "./prompt";
import { fetchPullRequest, fetchPullRequestDiff, createReview, postIssueComment, type ReviewComment } from "./github";

const MAX_COMMENTS = 100;

export type EventPayload = {
  issue?: {
    number?: number;
    pull_request?: unknown;
  };
  comment?: {
    body?: string;
  };
  repository?: {
    full_name?: string;
  };
};

export type Dependencies = {
  loadEventPayload: (path: string) => Promise<EventPayload>;
  fetchPullRequest: typeof fetchPullRequest;
  fetchPullRequestDiff: typeof fetchPullRequestDiff;
  createReview: typeof createReview;
  postIssueComment: typeof postIssueComment;
  createGeminiClient: (apiKey: string, modelName: string) => {
    review: (prompt: string) => Promise<AIReview[]>;
    reviewGlobal: (prompt: string) => Promise<AIGlobalReview>;
  };
};

export type RunResult = {
  skipped: boolean;
  skippedReason?: string;
  summary?: string;
  comments: ReviewComment[];
  reviews: AIReview[];
  globalReview?: AIGlobalReview;
};

export function summarizeComments(
  comments: ReviewComment[],
  reviews: AIReview[],
  fileCount: number,
  globalReview?: AIGlobalReview
): string {
  const counts: Record<string, number> = {
    critical: 0,
    high: 0,
    medium: 0,
    low: 0
  };

  for (const review of reviews) {
    const key = review.priority || "medium";
    if (counts[key] !== undefined) counts[key] += 1;
  }

  const lines: string[] = [];
  lines.push("ðŸ¤– **Gemini PR Review**");
  lines.push("");
  lines.push(`Reviewed **${fileCount}** file(s).`);
  lines.push(`Generated **${comments.length}** inline comment(s).`);
  lines.push("");

  const breakdown = [
    ["critical", "ðŸš¨"],
    ["high", "âš ï¸"],
    ["medium", "ðŸ’¡"],
    ["low", "â„¹ï¸"]
  ] as const;

  for (const [key, emoji] of breakdown) {
    lines.push(`- ${emoji} ${key}: ${counts[key]}`);
  }

  lines.push("");
  lines.push("> This review was automatically generated by Gemini. Please verify before applying changes.");

  if (globalReview && (globalReview.summary || globalReview.findings.length > 0)) {
    lines.push("");
    lines.push("## PR-level summary");
    if (globalReview.summary) {
      lines.push(globalReview.summary);
    }
    if (globalReview.findings.length > 0) {
      lines.push("");
      lines.push("Cross-file findings:");
      for (const finding of globalReview.findings) {
        lines.push(`- ${finding}`);
      }
    }
  }

  if (comments.length === 0) {
    lines.push("");
    lines.push("No issues detected in the reviewed changes.");
  }

  return lines.join("\n");
}

export async function loadEventPayload(path: string): Promise<EventPayload> {
  const raw = await readFile(path, "utf-8");
  return JSON.parse(raw) as EventPayload;
}

export function hasCommandTrigger(body: string, trigger: string): boolean {
  return body.toLowerCase().includes(trigger.toLowerCase());
}

export async function run(params: {
  config: Config;
  env: NodeJS.ProcessEnv;
  deps: Dependencies;
}): Promise<RunResult> {
  const { config, env, deps } = params;

  const eventPath = env.GITHUB_EVENT_PATH;
  const eventName = env.GITHUB_EVENT_NAME;

  if (!eventPath || !eventName) {
    throw new Error("Missing GITHUB_EVENT_PATH or GITHUB_EVENT_NAME");
  }

  if (eventName !== "issue_comment") {
    console.log(`Skipping: unsupported event ${eventName}`);
    return { skipped: true, skippedReason: `unsupported event ${eventName}`, comments: [], reviews: [] };
  }

  const event = await deps.loadEventPayload(eventPath);
  const isPullRequest = Boolean(event.issue?.pull_request);
  if (!isPullRequest) {
    console.log("Skipping: comment is not on a pull request");
    return { skipped: true, skippedReason: "not a pull request comment", comments: [], reviews: [] };
  }

  const commentBody = event.comment?.body || "";
  if (!hasCommandTrigger(commentBody, config.commandTrigger)) {
    console.log("Skipping: trigger not found in comment");
    return { skipped: true, skippedReason: "trigger not found", comments: [], reviews: [] };
  }

  const repoFullName = event.repository?.full_name || "";
  const [owner, repo] = repoFullName.split("/");
  const pullNumber = event.issue?.number || 0;

  if (!owner || !repo || !pullNumber) {
    throw new Error("Invalid repository or pull request details in event payload");
  }

  console.log(`Reviewing ${owner}/${repo}#${pullNumber}`);

  const pr = await deps.fetchPullRequest(owner, repo, pullNumber, config.githubToken);
  const diffText = await deps.fetchPullRequestDiff(owner, repo, pullNumber, config.githubToken);

  const parsedFiles = parseUnifiedDiff(diffText);
  const diffOptions = {
    includePatterns: config.includePatterns,
    excludePatterns: config.excludePatterns,
    maxFiles: config.maxFiles,
    maxHunksPerFile: config.maxHunksPerFile,
    maxLinesPerHunk: config.maxLinesPerHunk
  };
  const filteredFiles = filterDiffFiles(parsedFiles, diffOptions);

  const gemini = deps.createGeminiClient(config.geminiApiKey, config.geminiModel);

  const allReviews: AIReview[] = [];
  const comments: ReviewComment[] = [];
  const commentKeys = new Set<string>();
  let globalReview: AIGlobalReview | undefined;

  if (config.globalReview) {
    const globalDiff = buildGlobalDiff(filteredFiles, diffOptions, config.globalMaxLines);
    if (globalDiff) {
      const globalPrompt = buildGlobalPrompt({
        prTitle: pr.title,
        prDescription: pr.body,
        reviewMode: config.reviewMode,
        reviewInstructions: config.reviewInstructions,
        globalDiff
      });

      console.log(`Analyzing global PR context (${globalDiff.split("\n").length} lines)`);
      globalReview = await gemini.reviewGlobal(globalPrompt);
    }
  }

  for (const file of filteredFiles) {
    const numbered = buildNumberedPatch(file, {
      includePatterns: [],
      excludePatterns: [],
      maxFiles: config.maxFiles,
      maxHunksPerFile: config.maxHunksPerFile,
      maxLinesPerHunk: config.maxLinesPerHunk
    });

    if (numbered.lines.length === 0) continue;

    const prompt = buildPrompt({
      prTitle: pr.title,
      prDescription: pr.body,
      filePath: file.path,
      reviewMode: config.reviewMode,
      reviewInstructions: config.reviewInstructions,
      numberedDiff: numbered.lines.join("\n"),
      globalSummary: globalReview?.summary,
      globalFindings: globalReview?.findings
    });

    console.log(`Analyzing ${file.path} (${numbered.lines.length} diff lines)`);

    const reviews = await gemini.review(prompt);
    allReviews.push(...reviews);

    for (const review of reviews) {
      const adjustedPosition = adjustToReviewablePosition(
        review.lineNumber,
        numbered.lineMeta,
        numbered.hunkPositions
      );

      if (!adjustedPosition) continue;

      const key = `${file.path}:${adjustedPosition}:${review.reviewComment}`;
      if (commentKeys.has(key)) continue;
      commentKeys.add(key);

      comments.push({
        path: file.path,
        position: adjustedPosition,
        body: review.reviewComment
      });

      if (comments.length >= MAX_COMMENTS) break;
    }

    if (comments.length >= MAX_COMMENTS) break;
  }

  const summary = summarizeComments(comments, allReviews, filteredFiles.length, globalReview);

  try {
    await deps.createReview(pr, config.githubToken, summary, comments);
    console.log("Review created successfully");
  } catch (error) {
    console.error(`Failed to create review: ${(error as Error).message}`);
    console.log("Posting summary as issue comment instead...");
    await deps.postIssueComment(pr, config.githubToken, summary);
  }

  return { skipped: false, summary, comments, reviews: allReviews, globalReview };
}

async function main(): Promise<void> {
  const config = loadConfig();

  const deps: Dependencies = {
    loadEventPayload,
    fetchPullRequest,
    fetchPullRequestDiff,
    createReview,
    postIssueComment,
    createGeminiClient: (apiKey, modelName) => new GeminiClient(apiKey, modelName)
  };

  await run({ config, env: process.env, deps });
}

if (import.meta.main) {
  main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
  });
}
